{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"GrovePi Documentation \u00b6 The GrovePi is a Dexter Industries open-source platform for connecting Grove Sensors to the Raspberry Pi. With it you can bring the world of IoT devices to the Raspberry Pi and the only requirement for that is for you to know how to code in your language of choice. Whether it's a humidity/temperature sensor, distance sensor or an IR receiver or something as basic as an LED, the GrovePi can be your answer to these questions. By default, the language of choice for our library is Python, but support for other languages can be found too from our contributors such as: C/C++ NodeJS Java Go Ruby Scratch","title":"About"},{"location":"#grovepi-documentation","text":"The GrovePi is a Dexter Industries open-source platform for connecting Grove Sensors to the Raspberry Pi. With it you can bring the world of IoT devices to the Raspberry Pi and the only requirement for that is for you to know how to code in your language of choice. Whether it's a humidity/temperature sensor, distance sensor or an IR receiver or something as basic as an LED, the GrovePi can be your answer to these questions. By default, the language of choice for our library is Python, but support for other languages can be found too from our contributors such as: C/C++ NodeJS Java Go Ruby Scratch","title":"GrovePi Documentation"},{"location":"fw/","text":"Flashing the Firmware \u00b6 To flash the firmware, you must first have the GrovePi library/repository installed so for this you must follow the Getting Started guide . Once the library is installed on the Raspberry Pi, run the following commands to have the firmware flashed onto the GrovePi: cd ~/Dexter/GrovePi/Firmware bash firmware_update.sh This updates you to the latest version of the firmware which is the 1.4.0 . NOTE TO OTHER LIBRARIES Because the 1.3.0 firmware was recently released, lots of other libraries written in other languages other than Python are yet to be updated, so they need to run on an older version of the firmware, specifically the 1.2.7 . The 1.2.7 version can be found in ~/Dexter/GrovePi/Firmware/Archive as grove_pi_v1_2_7.cpp.hex . If you need to run on this older version, follow these steps to burn the firmware: mv ~/Dexter/GrovePi/Firmware/grove_pi_firmware.hex ~/Dexter/GrovePi/Firmware/grove_pi_v1_3_0.hex.bak cp ~/Dexter/GrovePi/Firmware/Archive/grove_pi_v1_2_7.cpp.hex ~/Dexter/GrovePi/Firmware/grove_pi_firmware.hex bash firmware_update.sh Running Tests \u00b6 To run the entire suite of tests for the GrovePi follow these bash instructions: cd ~/Dexter/GrovePi/Troubleshooting sudo bash all_tests.sh At the end of this process you'll get a log.txt file on your Desktop at ~/Desktop/log.txt . Also, to see with which version of the firmware the library installed on the Raspberry Pi works with you can go to ~/Dexter/GrovePi directory and run: python grovepi.py This should output a version number (of the GrovePi's firmware). Older versions of the firmware (<= v1.2.7 ) won't get displayed when calling python grovepi.py . pi@raspberrypi:~ $ python grovepi.py library supports this fw versions: 1 .4.0 To see which is the version of the current firmware loaded on the GrovePi you can either run the above test ( ... all_test.sh ) from the Troubleshooting/ directory or you can run these commands: import grovepi print ( grovepi . version ()) There are also cases when the GrovePi doesn't respond to requests. In this situation, you would normally see an exception appearing in Python. More often than not, these can be the source of problems: A non-present firmware on the GrovePi. A mismatch of versions between the firmware and the library on the Raspberry Pi. In both of these situations, re-flashing the firmware is all it's needed. Building the Firmware \u00b6 There may be cases where additional modification to the firmware is required to accommodate someone's particular requirements. In this case, building the firmware and then uploading it is crucial. During our production, we use PlatformIO along with Atom IDE . Once you get them both installed on your machine, open Atom IDE and add as a project the /Firmware/Source/grovepi directory. The added directory will have the following structure: lib/ src/ .gitignore .travis.yml extra_script.py platformio.ini Next, click on the build button or use ALT-CTRL-B key combination to build the firmware with PlatformIO. Once that it's done, head over to /Firmware/Source/grovepi/.pioenvs/grovepi directory and notice the firmware.hex . That's the firmware that was just built. You can then burn that to your GrovePi. Resetting the GrovePi \u00b6 To reset the GrovePi from your Raspberry Pi, run the following command provided you have installed the GrovePi library on your image: avrdude -c gpio -p m328p","title":"Firmware Stuff"},{"location":"fw/#flashing-the-firmware","text":"To flash the firmware, you must first have the GrovePi library/repository installed so for this you must follow the Getting Started guide . Once the library is installed on the Raspberry Pi, run the following commands to have the firmware flashed onto the GrovePi: cd ~/Dexter/GrovePi/Firmware bash firmware_update.sh This updates you to the latest version of the firmware which is the 1.4.0 . NOTE TO OTHER LIBRARIES Because the 1.3.0 firmware was recently released, lots of other libraries written in other languages other than Python are yet to be updated, so they need to run on an older version of the firmware, specifically the 1.2.7 . The 1.2.7 version can be found in ~/Dexter/GrovePi/Firmware/Archive as grove_pi_v1_2_7.cpp.hex . If you need to run on this older version, follow these steps to burn the firmware: mv ~/Dexter/GrovePi/Firmware/grove_pi_firmware.hex ~/Dexter/GrovePi/Firmware/grove_pi_v1_3_0.hex.bak cp ~/Dexter/GrovePi/Firmware/Archive/grove_pi_v1_2_7.cpp.hex ~/Dexter/GrovePi/Firmware/grove_pi_firmware.hex bash firmware_update.sh","title":"Flashing the Firmware"},{"location":"fw/#running-tests","text":"To run the entire suite of tests for the GrovePi follow these bash instructions: cd ~/Dexter/GrovePi/Troubleshooting sudo bash all_tests.sh At the end of this process you'll get a log.txt file on your Desktop at ~/Desktop/log.txt . Also, to see with which version of the firmware the library installed on the Raspberry Pi works with you can go to ~/Dexter/GrovePi directory and run: python grovepi.py This should output a version number (of the GrovePi's firmware). Older versions of the firmware (<= v1.2.7 ) won't get displayed when calling python grovepi.py . pi@raspberrypi:~ $ python grovepi.py library supports this fw versions: 1 .4.0 To see which is the version of the current firmware loaded on the GrovePi you can either run the above test ( ... all_test.sh ) from the Troubleshooting/ directory or you can run these commands: import grovepi print ( grovepi . version ()) There are also cases when the GrovePi doesn't respond to requests. In this situation, you would normally see an exception appearing in Python. More often than not, these can be the source of problems: A non-present firmware on the GrovePi. A mismatch of versions between the firmware and the library on the Raspberry Pi. In both of these situations, re-flashing the firmware is all it's needed.","title":"Running Tests"},{"location":"fw/#building-the-firmware","text":"There may be cases where additional modification to the firmware is required to accommodate someone's particular requirements. In this case, building the firmware and then uploading it is crucial. During our production, we use PlatformIO along with Atom IDE . Once you get them both installed on your machine, open Atom IDE and add as a project the /Firmware/Source/grovepi directory. The added directory will have the following structure: lib/ src/ .gitignore .travis.yml extra_script.py platformio.ini Next, click on the build button or use ALT-CTRL-B key combination to build the firmware with PlatformIO. Once that it's done, head over to /Firmware/Source/grovepi/.pioenvs/grovepi directory and notice the firmware.hex . That's the firmware that was just built. You can then burn that to your GrovePi.","title":"Building the Firmware"},{"location":"fw/#resetting-the-grovepi","text":"To reset the GrovePi from your Raspberry Pi, run the following command provided you have installed the GrovePi library on your image: avrdude -c gpio -p m328p","title":"Resetting the GrovePi"},{"location":"hw/","text":"Port Layout \u00b6 The GrovePi+ has multiple types of ports: Analog ports - A0 , A1 , A2 - with these ports you can read the voltage output of sensors. In this diagram, these ports are coloured in blue. When using the ports with our API, only use integers to designate the port of your choice such as 0 , 1 or 2 . Digital ports - D2 , D3 , D4 , D5 , D6 , D7 , D8 - with these ports you can read and write digital values of 1 or 0. In the above diagram, these ports are coloured in orange. When using the ports with our API, only use integers to designate the port of your choice such as 2 , 3 ... 8 . PWM port - 3 , 5 , 6 , 9 - with these ports you can set a specific voltage output between 0V and 5V by using the concept of duty cycle / PWN / PPM. I2C ports - which are coloured in yellow and have the SDA & SCL acronyms written. The master of this connection is the Raspberry Pi. Serial ports - which are found in the bottom-left corner of the above diagram. SERIAL port is the GrovePi's port whereas RPISER is a bypass to the Raspberry Pi's port, which has a level converter implemented to accept 5V signals. Numbering System \u00b6 Most of the sensors/actuators that we support have the signal line on the outwards of the grove port. For instance, the Grove LED has the signal line on the edge of the grove port which corresponds to port number 4 on port name D4 , so for us this was the reason why the port names we have given actually depend on where the signal lines mostly reside. Looking at a typical grove cable that comes with any GrovePi kit, the signal line is generally the yellow wire and the white wire is left unused. As you might have guessed, the yellow wire is the outermost wire of the grove cable.","title":"Hardware Ports"},{"location":"hw/#port-layout","text":"The GrovePi+ has multiple types of ports: Analog ports - A0 , A1 , A2 - with these ports you can read the voltage output of sensors. In this diagram, these ports are coloured in blue. When using the ports with our API, only use integers to designate the port of your choice such as 0 , 1 or 2 . Digital ports - D2 , D3 , D4 , D5 , D6 , D7 , D8 - with these ports you can read and write digital values of 1 or 0. In the above diagram, these ports are coloured in orange. When using the ports with our API, only use integers to designate the port of your choice such as 2 , 3 ... 8 . PWM port - 3 , 5 , 6 , 9 - with these ports you can set a specific voltage output between 0V and 5V by using the concept of duty cycle / PWN / PPM. I2C ports - which are coloured in yellow and have the SDA & SCL acronyms written. The master of this connection is the Raspberry Pi. Serial ports - which are found in the bottom-left corner of the above diagram. SERIAL port is the GrovePi's port whereas RPISER is a bypass to the Raspberry Pi's port, which has a level converter implemented to accept 5V signals.","title":"Port Layout"},{"location":"hw/#numbering-system","text":"Most of the sensors/actuators that we support have the signal line on the outwards of the grove port. For instance, the Grove LED has the signal line on the edge of the grove port which corresponds to port number 4 on port name D4 , so for us this was the reason why the port names we have given actually depend on where the signal lines mostly reside. Looking at a typical grove cable that comes with any GrovePi kit, the signal line is generally the yellow wire and the white wire is left unused. As you might have guessed, the yellow wire is the outermost wire of the grove cable.","title":"Numbering System"},{"location":"quickstart/","text":"Stacking It \u00b6 To get the GrovePi up and running we first need to attach the GrovePi to the RaspberryPi. It's a very simple process where it only needs to be stacked on top the GrovePi just like with any other hat. Before powering the Pi up, you need to make sure there's no foam sticked to the headers as that can trigger the Raspberry Pi to reboot. That's because the foam is electrically conductive and it basically shorts the pins. In the end the GrovePi will sit on the Raspberry Pi like in the following photo. How to Install \u00b6 When it comes to installation there are 2 ways to do it: By using our pre-made image called Raspbian For Robots . By using a fresh Raspbian image and running our install command. For Raspbian For Robots Image \u00b6 The benefit of using our image is that you don't have to worry about installing the GrovePi - because it's already on it. Still after a while you will be required to run updates via the console or via our GUI app in order to get the latest. For Manual Installation \u00b6 On the other hand, when using a fresh Raspbian image the initial installation takes some time, but subsequent updates take way less. The disadvantage with method is that you don't get the other robots installed too, so if you don't want to use other robots from our family then this method is the preferred one. To install the GrovePi on a fresh image of Raspbian, run the following command: curl -kL dexterindustries.com/update_grovepi | bash How to Update to a Newer Version \u00b6 Regardless of how you got the GrovePi installed (manually or by getting the Raspbian For Robots image), there's only one way to update to the latest version: curl -kL dexterindustries.com/update_grovepi | bash As you can see it's basically the same command used for installing the library on a fresh Raspbian image. Where Is It Installed \u00b6 Upon installing the GrovePi or getting our flavored image the GrovePi library can be found in /home/pi/Dexter/GrovePi directory. The /home/pi/Dexter/GrovePi is a mirrored version of our GitHub repository of the master branch. What I2C Bus to Use \u00b6 By default, the GrovePi library is set to use the RPI_1SW bus, which is a software implementation of the I2C specifically built to circumvent the issues with the hardware I2C of the Raspberry Pi. It's very fast and it doesn't use much CPU time at all. We recommend using this bus, thus, when importing the grovepi module, you don't have to do anything. There's also the RPI_1 , the classic HW I2C of the Raspberry Pi, which is buggy and unreliable. We don't see any reason in using this one in any scenario. Period. In order to change the bus, presumably to RPI_1 bus, call grovepi.set_bus(\"RPI_1\") or grovepi.set_bus(\"RPI_1SW\") in case you've changed the default one. Scratch Support \u00b6 Scratch support comes by default with our flavored image, Raspbian For Robots, but if you find yourself to be using the classic Raspbian then you also need to run the following command after you have installed the GrovePi: sudo bash /home/pi/Dexter/GrovePi/Script/install_scratch.sh Community Support \u00b6 To find out more on the GrovePi you can visit our forum and check for threads with the grovepi tag or by going to the GrovePi category .","title":"Getting Started"},{"location":"quickstart/#stacking-it","text":"To get the GrovePi up and running we first need to attach the GrovePi to the RaspberryPi. It's a very simple process where it only needs to be stacked on top the GrovePi just like with any other hat. Before powering the Pi up, you need to make sure there's no foam sticked to the headers as that can trigger the Raspberry Pi to reboot. That's because the foam is electrically conductive and it basically shorts the pins. In the end the GrovePi will sit on the Raspberry Pi like in the following photo.","title":"Stacking It"},{"location":"quickstart/#how-to-install","text":"When it comes to installation there are 2 ways to do it: By using our pre-made image called Raspbian For Robots . By using a fresh Raspbian image and running our install command.","title":"How to Install"},{"location":"quickstart/#for-raspbian-for-robots-image","text":"The benefit of using our image is that you don't have to worry about installing the GrovePi - because it's already on it. Still after a while you will be required to run updates via the console or via our GUI app in order to get the latest.","title":"For Raspbian For Robots Image"},{"location":"quickstart/#for-manual-installation","text":"On the other hand, when using a fresh Raspbian image the initial installation takes some time, but subsequent updates take way less. The disadvantage with method is that you don't get the other robots installed too, so if you don't want to use other robots from our family then this method is the preferred one. To install the GrovePi on a fresh image of Raspbian, run the following command: curl -kL dexterindustries.com/update_grovepi | bash","title":"For Manual Installation"},{"location":"quickstart/#how-to-update-to-a-newer-version","text":"Regardless of how you got the GrovePi installed (manually or by getting the Raspbian For Robots image), there's only one way to update to the latest version: curl -kL dexterindustries.com/update_grovepi | bash As you can see it's basically the same command used for installing the library on a fresh Raspbian image.","title":"How to Update to a Newer Version"},{"location":"quickstart/#where-is-it-installed","text":"Upon installing the GrovePi or getting our flavored image the GrovePi library can be found in /home/pi/Dexter/GrovePi directory. The /home/pi/Dexter/GrovePi is a mirrored version of our GitHub repository of the master branch.","title":"Where Is It Installed"},{"location":"quickstart/#what-i2c-bus-to-use","text":"By default, the GrovePi library is set to use the RPI_1SW bus, which is a software implementation of the I2C specifically built to circumvent the issues with the hardware I2C of the Raspberry Pi. It's very fast and it doesn't use much CPU time at all. We recommend using this bus, thus, when importing the grovepi module, you don't have to do anything. There's also the RPI_1 , the classic HW I2C of the Raspberry Pi, which is buggy and unreliable. We don't see any reason in using this one in any scenario. Period. In order to change the bus, presumably to RPI_1 bus, call grovepi.set_bus(\"RPI_1\") or grovepi.set_bus(\"RPI_1SW\") in case you've changed the default one.","title":"What I2C Bus to Use"},{"location":"quickstart/#scratch-support","text":"Scratch support comes by default with our flavored image, Raspbian For Robots, but if you find yourself to be using the classic Raspbian then you also need to run the following command after you have installed the GrovePi: sudo bash /home/pi/Dexter/GrovePi/Script/install_scratch.sh","title":"Scratch Support"},{"location":"quickstart/#community-support","text":"To find out more on the GrovePi you can visit our forum and check for threads with the grovepi tag or by going to the GrovePi category .","title":"Community Support"},{"location":"release-notes/","text":"Release Notes For the Firmware \u00b6 Maintenance Team \u00b6 The current and past members of the GrovePi team in alphabetical order are: @CleoQc @johnisanerd @karan259 @RobertLucian Also, we have a couple of notable contributors to the GrovePi but for other libraries: @marcellobarile for the NodeJS library @mcauser for adding different new functionalities/bug fixes/examples to our current library @lanselambor @nikkoura @lucavallin for coming with fixes to the Go library @rpedersen for C# stuff @k33g for Java library Version 1.4.0 - 27 April 2019 \u00b6 Add support for setting up interrupt events on each digital port of the GrovePi, thus breaking the limit of just two available hardware interrupts #446 Enable the Grove Dust Sensor, the Grove Encoder and the Grove Flow Meter to work on any digital port of the GrovePi and support 7 or 3 or respectively 7 devices at the same time #446 Version 1.3.0 - 1 Aug 2018 \u00b6 Fixed synchronization bugs which led to very small IO rates Also caused values to overlap on other ports #412 Caused I2C errors when functions were called with no delay between them #409 Small refactorization of the code to something slightly better Fixed the dust sensor #408 Mitigated abnormality caused by the Raspberry Pi not supporting clock stretching on the I2C #411 Debugged and sped up the rate of acquisition of the DHT sensor #418 Add IR receiver functionality for any remote control and fix inherent issues with the library #416 Add option to set the flow meter and the dust sensor on different ports other than D2 #421 Version 1.2.7 - 20 Dec 2016 \u00b6 Faster IO Less IO Errors RTC and MMA7xxx accelerometer code removed from the firmware Version 1.2.2 - 22 Jan 2015 \u00b6 Grove Chainable RGB LED added Ability to persist a RGB color in memory for later use Version 1.2.1 - 30 Dec 2014 \u00b6 Grove 4 Digit Display added Version 1.2.0 - 29 Dec 2014 \u00b6 Grove LED Bar added Firmware version made available Version 1.1 - 13 Feb 2014 \u00b6 DHT, ultrasonic, RTC code added Support for multiple modules for same type added (Not tested) Protocol made more robust","title":"Release Notes"},{"location":"release-notes/#release-notes-for-the-firmware","text":"","title":"Release Notes For the Firmware"},{"location":"release-notes/#maintenance-team","text":"The current and past members of the GrovePi team in alphabetical order are: @CleoQc @johnisanerd @karan259 @RobertLucian Also, we have a couple of notable contributors to the GrovePi but for other libraries: @marcellobarile for the NodeJS library @mcauser for adding different new functionalities/bug fixes/examples to our current library @lanselambor @nikkoura @lucavallin for coming with fixes to the Go library @rpedersen for C# stuff @k33g for Java library","title":"Maintenance Team"},{"location":"release-notes/#version-140-27-april-2019","text":"Add support for setting up interrupt events on each digital port of the GrovePi, thus breaking the limit of just two available hardware interrupts #446 Enable the Grove Dust Sensor, the Grove Encoder and the Grove Flow Meter to work on any digital port of the GrovePi and support 7 or 3 or respectively 7 devices at the same time #446","title":"Version 1.4.0 - 27 April 2019"},{"location":"release-notes/#version-130-1-aug-2018","text":"Fixed synchronization bugs which led to very small IO rates Also caused values to overlap on other ports #412 Caused I2C errors when functions were called with no delay between them #409 Small refactorization of the code to something slightly better Fixed the dust sensor #408 Mitigated abnormality caused by the Raspberry Pi not supporting clock stretching on the I2C #411 Debugged and sped up the rate of acquisition of the DHT sensor #418 Add IR receiver functionality for any remote control and fix inherent issues with the library #416 Add option to set the flow meter and the dust sensor on different ports other than D2 #421","title":"Version 1.3.0 - 1 Aug 2018"},{"location":"release-notes/#version-127-20-dec-2016","text":"Faster IO Less IO Errors RTC and MMA7xxx accelerometer code removed from the firmware","title":"Version 1.2.7 - 20 Dec 2016"},{"location":"release-notes/#version-122-22-jan-2015","text":"Grove Chainable RGB LED added Ability to persist a RGB color in memory for later use","title":"Version 1.2.2 - 22 Jan 2015"},{"location":"release-notes/#version-121-30-dec-2014","text":"Grove 4 Digit Display added","title":"Version 1.2.1 - 30 Dec 2014"},{"location":"release-notes/#version-120-29-dec-2014","text":"Grove LED Bar added Firmware version made available","title":"Version 1.2.0 - 29 Dec 2014"},{"location":"release-notes/#version-11-13-feb-2014","text":"DHT, ultrasonic, RTC code added Support for multiple modules for same type added (Not tested) Protocol made more robust","title":"Version 1.1 - 13 Feb 2014"},{"location":"supported/","text":"Supported Modules \u00b6 A grid list of supported modules (sensors and actuators) can be seen on our page somewhere in the middle of it - you need to scroll down quite a lot. Upon scrolling down, you'll see a list that looks like this one down below. DI-Sensors \u00b6 The GrovePi can also be used along with our DI-Sensors that require an I2C interface. The GrovePi has 3 I2C ports which can be used for interfacing with these sensors. More can be found in the DI-Sensors Documentation .","title":"Supported Modules"},{"location":"supported/#supported-modules","text":"A grid list of supported modules (sensors and actuators) can be seen on our page somewhere in the middle of it - you need to scroll down quite a lot. Upon scrolling down, you'll see a list that looks like this one down below.","title":"Supported Modules"},{"location":"supported/#di-sensors","text":"The GrovePi can also be used along with our DI-Sensors that require an I2C interface. The GrovePi has 3 I2C ports which can be used for interfacing with these sensors. More can be found in the DI-Sensors Documentation .","title":"DI-Sensors"},{"location":"api/complex/","text":"API - Complex Devices \u00b6 In this section the Python API reference for more complex devices is described. This library is supported on both major versions of Python: 2.x and 3.x. The API for the following sensors is described in this section: Grove LED bar Grove 4-Digit Display Grove Chainable RGB LED IMPORTANT This library and the other ones too are not thread-safe. You cannot call the GrovePi from multiple threads or processes as that will put the GrovePi into a broken state. In case you need to reset the GrovePi from your Raspberry Pi, check this section . The functions don't verify if the input parameters are valid and therefore the parameters have to be verified/validated before that. Calling a function with improper parameters can result in an undefined behavior for the GrovePi. grovepi.ledBar_init(pin, orientation) \u00b6 Initialize an LED bar . Parameters pin {Integer} a number to identify the port (D2-D8) to which the LED bar is assigned to orientation {Integer} 0 to go from red to green or 1 to go the other way Returns : 1 all the time grovepi.ledBar_orientation(pin, orientation) \u00b6 Set the orientation on an already initialized LED bar . Parameters pin {Integer} a number to identify the port (D2-D8) to which the LED bar is assigned to orientation {Integer} 0 to go from red to green or 1 to go the other way Returns : 1 all the time grovepi.ledBar_setLevel(pin, level) \u00b6 Set the level on an LED bar . Parameters pin {Integer} a number to identify the port (D2-D8) to which the LED bar is assigned to orientation {Integer} 0 to 10 corresponding to the number of levels that exist on the LED bar. Returns : 1 all the time grovepi.ledBar_toggleLed(pin, led) \u00b6 Toggle the state of one LED of the 10 levels of the LED bar . Parameters pin {Integer} a number to identify the port (D2-D8) to which the LED bar is assigned to led {Integer} taking values from 0 to 10 depending on which LED to toggle Returns : 1 all the time grovepi.ledBar_setBits(pin, state) \u00b6 Set the LED activations of the LED bar based on the binary representation of a 10-bit number. Parameters pin {Integer} a number to identify the port (D2-D8) to which the LED bar is assigned to state {Integer} a number from 0 to 1023 that covers all states for all 10 LEDs of the LED bar Returns : 1 all the time grovepi.ledBar_getBits(pin) \u00b6 Read the state of LED activations on the LED bar . Parameters pin {Integer} a number to identify the port (D2-D8) to which the LED bar is assigned to Returns : a number from 0 to 1023 to represent the binary state of all 10 LEDs of the LED bar grovepi.fourDigit_init(pin) \u00b6 Initialize a Grove 4-Digit Display . Parameters pin {Integer} the port (D2-D8) to which the 4-Digit display is set to Returns : 1 all the time grovepi.fourDigit_number(pin, value, leading_zero) \u00b6 Set the Grove 4-Digit Display to display a number. Parameters pin {Integer} the port (D2-D8) to which the 4-Digit display is set to value {Integer} a value between 0 and 9999 representing the number to be printed on the display leading_zero {Boolean} whether to add leading zeros or not Returns : 1 all the time grovepi.fourDigit_brightness(pin, brightness) \u00b6 Set the brightness of the Grove 4-Digit Display . Parameters pin {Integer} the port (D2-D8) to which the 4-Digit display is set to brightness {Integer} a number between 0 (for the darkest option) and 7 (for the brightest) representing the brightness of the display Returns : 1 all the time grovepi.fourDigit_digit(pin, segment, value) \u00b6 Set individual segment of the Grove 4-Digit Display . Parameters pin {Integer} the port (D2-D8) to which the 4-Digit display is set to segment {Integer} a number from 0 to 3 representing the segment value {Integer} value of the segment - 0 to 15 Returns : 1 all the time grovepi.fourDigit_segment(pin, segment, leds) \u00b6 Set the individual LED segments of a digit of the Grove 4-Digit Display . Parameters pin {Integer} the port (D2-D8) to which the 4-Digit display is set to segment {Integer} which segment of the display to modify ( 0 to 3 ) leds {Integer} a number from 0 to 255 representing the binary activations of the selected segment - the 8th bit is the colon Returns : 1 all the time grovepi.fourDigit_score(pin, left, right) \u00b6 Set values on either side of the Grove 4-Digit Display . To the left and right values, leading zeros are added and the colon is lit up Parameters pin {Integer} the port (D2-D8) to which the 4-Digit display is set to left {Integer} value to be displayed on the left side of the display (takes values from 0 to 99 ) right {Integer} value to be displayed on the right side of the display (takes values from 0 to 99 ) Returns : 1 all the time grovepi.fourDigit_monitor(pin, analog, duration) \u00b6 Display the analogRead values onto the Grove 4-Digit Display for a given time. Parameters pin {Integer} the port (D2-D8) to which the 4-Digit display is set to analog {Integer} the port (A0-A2) on which analog values are read from duration {Integer} for how many seconds ( 0 to 255 ) the readings are to be displayed Returns : 1 all the time grovepi.fourDigit_on(pin) \u00b6 Turn the whole Grove 4-Digit Display on. Parameters pin {Integer} the port (D2-D8) to which the 4-Digit display is set to Returns : 1 all the time grovepi.fourDigit_off(pin) \u00b6 Turn the whole Grove 4-Digit Display off. Parameters pin {Integer} the port (D2-D8) to which the 4-Digit display is set to Returns : 1 all the time grovepi.storeColor(red, green, blue) \u00b6 Store a color for later use with the Grove Chainable RGB LED . Parameters red {Integer} value from 0 to 255 green {Integer} value from 0 to 255 blue {Integer} value from 0 to 255 Returns : 1 all the time grovepi.chainableRgbLed_init(pin, numLeds) \u00b6 Initialize a number of chained LEDs on given port. Parameters pin {Integer} the port (D2-D8) to which the Grove RGB LED(s) are connected to numLeds {Integer} number of chained LEDs Returns : 1 all the time grovepi.chainableRgbLed_test(pin, numLeds, testColor) \u00b6 Initialize chained LEDs on given port and set a test color on all of them. Parameters pin {Integer} the port (D2-D8) to which the Grove RGB LED(s) are connected to numLeds {Integer} number of chained LEDs testColor {Integer} the color to use for all chained LEDs 0 for black (or nothing) 1 for blue 2 for green 3 for cyan 4 for red 5 for magenta 6 for yellow 7 for white Returns : 1 all the time grovepi.chainableRgbLed_pattern(pin, pattern, whichLed) \u00b6 Set one or more chained LEDs to a stored color following a given pattern. Parameters pin {Integer} the port (D2-D8) to which the Grove RGB LED(s) are connected to pattern {Integer} 0 for this LED only 1 for all LEDs except this LED 2 this LED and all LEDs inwards 3 this LED and all LEDs outwards whichLed {Integer} the index of the LED you wish to set counting outwards from the GrovePi starting with 0 Returns : 1 all the time grovepi.chainableRgbLed_modulo(pin, offset, divisor) \u00b6 Set one or more chained LEDs to a stored color following the \"pattern\" of the modulo operation. Parameters pin {Integer} the port (D2-D8) to which the Grove RGB LED(s) are connected to offset {Integer} the index of the LED you want to start at ( 0 is for the 1st LED) divisor {Integer} sets the color to those LEDs of whose indexes divided by divisor have the remainder set to 0 - for divisor=1 every LED gets set, but for divisor=2 every 2nd LED gets set Returns : 1 all the time grovepi.chainableRgbLed_setLevel(pin, level, reverse) \u00b6 Set one or more chained LEDs to a stored color similar to a bar graph. Parameters pin {Integer} the port (D2-D8) to which the Grove RGB LED(s) are connected to level {Integer} the number of LEDs you want to set to the stored color reverse {Integer} 0 when counting outwards from the GrovePi or 1 when it's the other way (from the most outward LED inwards) Returns : 1 all the time","title":"Complex Devices"},{"location":"api/complex/#api-complex-devices","text":"In this section the Python API reference for more complex devices is described. This library is supported on both major versions of Python: 2.x and 3.x. The API for the following sensors is described in this section: Grove LED bar Grove 4-Digit Display Grove Chainable RGB LED IMPORTANT This library and the other ones too are not thread-safe. You cannot call the GrovePi from multiple threads or processes as that will put the GrovePi into a broken state. In case you need to reset the GrovePi from your Raspberry Pi, check this section . The functions don't verify if the input parameters are valid and therefore the parameters have to be verified/validated before that. Calling a function with improper parameters can result in an undefined behavior for the GrovePi.","title":"API - Complex Devices"},{"location":"api/complex/#grovepiledbar_initpin-orientation","text":"Initialize an LED bar . Parameters pin {Integer} a number to identify the port (D2-D8) to which the LED bar is assigned to orientation {Integer} 0 to go from red to green or 1 to go the other way Returns : 1 all the time","title":"grovepi.ledBar_init(pin, orientation)"},{"location":"api/complex/#grovepiledbar_orientationpin-orientation","text":"Set the orientation on an already initialized LED bar . Parameters pin {Integer} a number to identify the port (D2-D8) to which the LED bar is assigned to orientation {Integer} 0 to go from red to green or 1 to go the other way Returns : 1 all the time","title":"grovepi.ledBar_orientation(pin, orientation)"},{"location":"api/complex/#grovepiledbar_setlevelpin-level","text":"Set the level on an LED bar . Parameters pin {Integer} a number to identify the port (D2-D8) to which the LED bar is assigned to orientation {Integer} 0 to 10 corresponding to the number of levels that exist on the LED bar. Returns : 1 all the time","title":"grovepi.ledBar_setLevel(pin, level)"},{"location":"api/complex/#grovepiledbar_toggleledpin-led","text":"Toggle the state of one LED of the 10 levels of the LED bar . Parameters pin {Integer} a number to identify the port (D2-D8) to which the LED bar is assigned to led {Integer} taking values from 0 to 10 depending on which LED to toggle Returns : 1 all the time","title":"grovepi.ledBar_toggleLed(pin, led)"},{"location":"api/complex/#grovepiledbar_setbitspin-state","text":"Set the LED activations of the LED bar based on the binary representation of a 10-bit number. Parameters pin {Integer} a number to identify the port (D2-D8) to which the LED bar is assigned to state {Integer} a number from 0 to 1023 that covers all states for all 10 LEDs of the LED bar Returns : 1 all the time","title":"grovepi.ledBar_setBits(pin, state)"},{"location":"api/complex/#grovepiledbar_getbitspin","text":"Read the state of LED activations on the LED bar . Parameters pin {Integer} a number to identify the port (D2-D8) to which the LED bar is assigned to Returns : a number from 0 to 1023 to represent the binary state of all 10 LEDs of the LED bar","title":"grovepi.ledBar_getBits(pin)"},{"location":"api/complex/#grovepifourdigit_initpin","text":"Initialize a Grove 4-Digit Display . Parameters pin {Integer} the port (D2-D8) to which the 4-Digit display is set to Returns : 1 all the time","title":"grovepi.fourDigit_init(pin)"},{"location":"api/complex/#grovepifourdigit_numberpin-value-leading_zero","text":"Set the Grove 4-Digit Display to display a number. Parameters pin {Integer} the port (D2-D8) to which the 4-Digit display is set to value {Integer} a value between 0 and 9999 representing the number to be printed on the display leading_zero {Boolean} whether to add leading zeros or not Returns : 1 all the time","title":"grovepi.fourDigit_number(pin, value, leading_zero)"},{"location":"api/complex/#grovepifourdigit_brightnesspin-brightness","text":"Set the brightness of the Grove 4-Digit Display . Parameters pin {Integer} the port (D2-D8) to which the 4-Digit display is set to brightness {Integer} a number between 0 (for the darkest option) and 7 (for the brightest) representing the brightness of the display Returns : 1 all the time","title":"grovepi.fourDigit_brightness(pin, brightness)"},{"location":"api/complex/#grovepifourdigit_digitpin-segment-value","text":"Set individual segment of the Grove 4-Digit Display . Parameters pin {Integer} the port (D2-D8) to which the 4-Digit display is set to segment {Integer} a number from 0 to 3 representing the segment value {Integer} value of the segment - 0 to 15 Returns : 1 all the time","title":"grovepi.fourDigit_digit(pin, segment, value)"},{"location":"api/complex/#grovepifourdigit_segmentpin-segment-leds","text":"Set the individual LED segments of a digit of the Grove 4-Digit Display . Parameters pin {Integer} the port (D2-D8) to which the 4-Digit display is set to segment {Integer} which segment of the display to modify ( 0 to 3 ) leds {Integer} a number from 0 to 255 representing the binary activations of the selected segment - the 8th bit is the colon Returns : 1 all the time","title":"grovepi.fourDigit_segment(pin, segment, leds)"},{"location":"api/complex/#grovepifourdigit_scorepin-left-right","text":"Set values on either side of the Grove 4-Digit Display . To the left and right values, leading zeros are added and the colon is lit up Parameters pin {Integer} the port (D2-D8) to which the 4-Digit display is set to left {Integer} value to be displayed on the left side of the display (takes values from 0 to 99 ) right {Integer} value to be displayed on the right side of the display (takes values from 0 to 99 ) Returns : 1 all the time","title":"grovepi.fourDigit_score(pin, left, right)"},{"location":"api/complex/#grovepifourdigit_monitorpin-analog-duration","text":"Display the analogRead values onto the Grove 4-Digit Display for a given time. Parameters pin {Integer} the port (D2-D8) to which the 4-Digit display is set to analog {Integer} the port (A0-A2) on which analog values are read from duration {Integer} for how many seconds ( 0 to 255 ) the readings are to be displayed Returns : 1 all the time","title":"grovepi.fourDigit_monitor(pin, analog, duration)"},{"location":"api/complex/#grovepifourdigit_onpin","text":"Turn the whole Grove 4-Digit Display on. Parameters pin {Integer} the port (D2-D8) to which the 4-Digit display is set to Returns : 1 all the time","title":"grovepi.fourDigit_on(pin)"},{"location":"api/complex/#grovepifourdigit_offpin","text":"Turn the whole Grove 4-Digit Display off. Parameters pin {Integer} the port (D2-D8) to which the 4-Digit display is set to Returns : 1 all the time","title":"grovepi.fourDigit_off(pin)"},{"location":"api/complex/#grovepistorecolorred-green-blue","text":"Store a color for later use with the Grove Chainable RGB LED . Parameters red {Integer} value from 0 to 255 green {Integer} value from 0 to 255 blue {Integer} value from 0 to 255 Returns : 1 all the time","title":"grovepi.storeColor(red, green, blue)"},{"location":"api/complex/#grovepichainablergbled_initpin-numleds","text":"Initialize a number of chained LEDs on given port. Parameters pin {Integer} the port (D2-D8) to which the Grove RGB LED(s) are connected to numLeds {Integer} number of chained LEDs Returns : 1 all the time","title":"grovepi.chainableRgbLed_init(pin, numLeds)"},{"location":"api/complex/#grovepichainablergbled_testpin-numleds-testcolor","text":"Initialize chained LEDs on given port and set a test color on all of them. Parameters pin {Integer} the port (D2-D8) to which the Grove RGB LED(s) are connected to numLeds {Integer} number of chained LEDs testColor {Integer} the color to use for all chained LEDs 0 for black (or nothing) 1 for blue 2 for green 3 for cyan 4 for red 5 for magenta 6 for yellow 7 for white Returns : 1 all the time","title":"grovepi.chainableRgbLed_test(pin, numLeds, testColor)"},{"location":"api/complex/#grovepichainablergbled_patternpin-pattern-whichled","text":"Set one or more chained LEDs to a stored color following a given pattern. Parameters pin {Integer} the port (D2-D8) to which the Grove RGB LED(s) are connected to pattern {Integer} 0 for this LED only 1 for all LEDs except this LED 2 this LED and all LEDs inwards 3 this LED and all LEDs outwards whichLed {Integer} the index of the LED you wish to set counting outwards from the GrovePi starting with 0 Returns : 1 all the time","title":"grovepi.chainableRgbLed_pattern(pin, pattern, whichLed)"},{"location":"api/complex/#grovepichainablergbled_modulopin-offset-divisor","text":"Set one or more chained LEDs to a stored color following the \"pattern\" of the modulo operation. Parameters pin {Integer} the port (D2-D8) to which the Grove RGB LED(s) are connected to offset {Integer} the index of the LED you want to start at ( 0 is for the 1st LED) divisor {Integer} sets the color to those LEDs of whose indexes divided by divisor have the remainder set to 0 - for divisor=1 every LED gets set, but for divisor=2 every 2nd LED gets set Returns : 1 all the time","title":"grovepi.chainableRgbLed_modulo(pin, offset, divisor)"},{"location":"api/complex/#grovepichainablergbled_setlevelpin-level-reverse","text":"Set one or more chained LEDs to a stored color similar to a bar graph. Parameters pin {Integer} the port (D2-D8) to which the Grove RGB LED(s) are connected to level {Integer} the number of LEDs you want to set to the stored color reverse {Integer} 0 when counting outwards from the GrovePi or 1 when it's the other way (from the most outward LED inwards) Returns : 1 all the time","title":"grovepi.chainableRgbLed_setLevel(pin, level, reverse)"},{"location":"api/general/","text":"API - General Sensors \u00b6 In this section the Python API reference for diverse sensors is described. This library is supported on both major versions of Python: 2.x and 3.x. In this section, the API for the following sensors is described: Grove Temperature Sensor Grove Ultrasonic Sensor DHT11 DHT22 Grove IR Receiver necessary for the Infrared Remote IMPORTANT This library and the other ones too are not thread-safe. You cannot call the GrovePi from multiple threads or processes as that will put the GrovePi into a broken state. In case you need to reset the GrovePi from your Raspberry Pi, check this section . The functions don't verify if the input parameters are valid and therefore the parameters have to be verified/validated before that. Calling a function with improper parameters can result in an undefined behavior for the GrovePi. grovepi.temp(pin, model='1.0') \u00b6 Read temperature from the Grove Temperature Sensor on the GrovePi. Parameters pin {Integer} a number to identify the port (A0-A2) from which to do the reading model {String} \"1.0\" , \"1.1\" , \"1.2\" depending on the used model Returns : {Float} number to represent the temperature in \u00baC grovepi.ultrasonicRead(pin) \u00b6 Read the distance to an object with the Grove Ultrasonic Sensor on the GrovePi. The closer it is to the targeted object, the faster the sample rate and slower when it's farther. Parameters pin {Integer} a number to identify the port (D2-D8) from which to do the reading Returns : {Integer} number to represent the distance to the object in centimeters grovepi.version() \u00b6 Read the version of the firmware. Returns : a {String} representing the firmware version (i.e. \"1.2.7\" ) grovepi.dht(pin, module_type) \u00b6 Read the temperature and humidity on the GrovePi with one of the given modules. Parameters pin {Integer} a number to identify the port (D2-D8) from which to do the reading module_type {Integer} a number to identify the model 0 for DHT11 1 for DHT22 2 for DHT21 3 for AM2301 Returns : a {(Float, Float} list where the 1st parameter is the temperature in \u00baC and the 2nd one is the humidity as a percentage. On Error : it returns a {(Float, Float)} list containing NaN s. This happens when the sensor can't keep up with the demanded sample rate. grovepi.ir_read_signal() \u00b6 Get the decoded value from the Grove IR Receiver . For this you need to use a remote control of any kind. The preferred one we use is the Infrared Remote . In order to use this function, you first need to call grovepi.ir_recv_pin function to bind the functionality to a given port. Parameters : None Returns : a 3-element list of this form {(Integer, Integer, Integer)} The 1st element keeps an {Integer} corresponding to a certain brand: -1 for unknown and 0 for unused RC2, RC5, NEC, SONY, PANASONIC, JVC, SAMSUNG, WHYNTER, AIWA_RC_T501, LG, SANYO, MITSUBISHI, DISH, SHARP, DENON, PRONTO, LEGO_PF having values from 1 to 17 The 2nd element is a 16-bit address used by some Panasonic and Sharp remotes The 3rd element is the 32-bit decoded value that can be used to identify which buttons were pressed - since there's no map for them you need to do it on a case-by-case basis grovepi.ir_recv_pin(pin) \u00b6 Enable the Grove IR Receiver on a given port. Used in conjunction with grovepi.ir_read_signal and grovepi.ir_is_data . Parameters pin {Integer} The port (D2-D8) to which the IR receiver gets connected to Returns : None grovepi.ir_is_data() \u00b6 Checks if there's available data coming from the Grove IR Receiver . Used in conjunction with grovepi.ir_read_signal function. Parameters : None Returns : True or False","title":"General Sensors"},{"location":"api/general/#api-general-sensors","text":"In this section the Python API reference for diverse sensors is described. This library is supported on both major versions of Python: 2.x and 3.x. In this section, the API for the following sensors is described: Grove Temperature Sensor Grove Ultrasonic Sensor DHT11 DHT22 Grove IR Receiver necessary for the Infrared Remote IMPORTANT This library and the other ones too are not thread-safe. You cannot call the GrovePi from multiple threads or processes as that will put the GrovePi into a broken state. In case you need to reset the GrovePi from your Raspberry Pi, check this section . The functions don't verify if the input parameters are valid and therefore the parameters have to be verified/validated before that. Calling a function with improper parameters can result in an undefined behavior for the GrovePi.","title":"API - General Sensors"},{"location":"api/general/#grovepitemppin-model10","text":"Read temperature from the Grove Temperature Sensor on the GrovePi. Parameters pin {Integer} a number to identify the port (A0-A2) from which to do the reading model {String} \"1.0\" , \"1.1\" , \"1.2\" depending on the used model Returns : {Float} number to represent the temperature in \u00baC","title":"grovepi.temp(pin, model='1.0')"},{"location":"api/general/#grovepiultrasonicreadpin","text":"Read the distance to an object with the Grove Ultrasonic Sensor on the GrovePi. The closer it is to the targeted object, the faster the sample rate and slower when it's farther. Parameters pin {Integer} a number to identify the port (D2-D8) from which to do the reading Returns : {Integer} number to represent the distance to the object in centimeters","title":"grovepi.ultrasonicRead(pin)"},{"location":"api/general/#grovepiversion","text":"Read the version of the firmware. Returns : a {String} representing the firmware version (i.e. \"1.2.7\" )","title":"grovepi.version()"},{"location":"api/general/#grovepidhtpin-module_type","text":"Read the temperature and humidity on the GrovePi with one of the given modules. Parameters pin {Integer} a number to identify the port (D2-D8) from which to do the reading module_type {Integer} a number to identify the model 0 for DHT11 1 for DHT22 2 for DHT21 3 for AM2301 Returns : a {(Float, Float} list where the 1st parameter is the temperature in \u00baC and the 2nd one is the humidity as a percentage. On Error : it returns a {(Float, Float)} list containing NaN s. This happens when the sensor can't keep up with the demanded sample rate.","title":"grovepi.dht(pin, module_type)"},{"location":"api/general/#grovepiir_read_signal","text":"Get the decoded value from the Grove IR Receiver . For this you need to use a remote control of any kind. The preferred one we use is the Infrared Remote . In order to use this function, you first need to call grovepi.ir_recv_pin function to bind the functionality to a given port. Parameters : None Returns : a 3-element list of this form {(Integer, Integer, Integer)} The 1st element keeps an {Integer} corresponding to a certain brand: -1 for unknown and 0 for unused RC2, RC5, NEC, SONY, PANASONIC, JVC, SAMSUNG, WHYNTER, AIWA_RC_T501, LG, SANYO, MITSUBISHI, DISH, SHARP, DENON, PRONTO, LEGO_PF having values from 1 to 17 The 2nd element is a 16-bit address used by some Panasonic and Sharp remotes The 3rd element is the 32-bit decoded value that can be used to identify which buttons were pressed - since there's no map for them you need to do it on a case-by-case basis","title":"grovepi.ir_read_signal()"},{"location":"api/general/#grovepiir_recv_pinpin","text":"Enable the Grove IR Receiver on a given port. Used in conjunction with grovepi.ir_read_signal and grovepi.ir_is_data . Parameters pin {Integer} The port (D2-D8) to which the IR receiver gets connected to Returns : None","title":"grovepi.ir_recv_pin(pin)"},{"location":"api/general/#grovepiir_is_data","text":"Checks if there's available data coming from the Grove IR Receiver . Used in conjunction with grovepi.ir_read_signal function. Parameters : None Returns : True or False","title":"grovepi.ir_is_data()"},{"location":"api/gpio/","text":"API - GPIO Functions \u00b6 In this section the Python API reference for GPIO functions is described. This library is supported on both major versions of Python: 2.x and 3.x. IMPORTANT This library and the other ones too are not thread-safe. You cannot call the GrovePi from multiple threads or processes as that will put the GrovePi into a broken state. In case you need to reset the GrovePi from your Raspberry Pi, check this section . The functions don't verify if the input parameters are valid and therefore the parameters have to be verified/validated before that. Calling a function with improper parameters can result in an undefined behavior for the GrovePi. grovepi.digitalRead(pin) \u00b6 Reads whether a port's input is set high or low on the GrovePi. Parameters pin {Integer} a number to identify the port (D2-D8) from which to do the reading Returns : 0 or 1 depending on the input value grovepi.digitalWrite(pin, value) \u00b6 Sets the output value to either 0 or 1 to a digital port on the GrovePi. Parameters pin {Integer} a number to identify the port (D2-D8) to which to do the writing value {Integer} either 0 for 0 volts or 1 for maximum output voltage (usually 5 volts) Returns : 1 all the time grovepi.analogRead(pin) \u00b6 Detect an input voltage as a value from a given port on the GrovePi. Parameters pin {Integer} a number to identify the port (A0-A2) from which to do the reading Returns : a 10-bit {Integer} number that maps to the input voltage on the port grovepi.analogWrite(pin, value) \u00b6 Set an output voltage on a PWM-enabled port by mapping the value to the desired voltage on the GrovePi. Parameters pin {Integer} a number to identify the port (ports 3, 5, 6, 9) to which to do the writing value {Integer} an 8-bit number that maps from 0V to the referenced voltage of the GrovePi (5V) Returns : 1 all the time grovepi.pinMode(pin, mode) \u00b6 Sets a port to be either an OUTPUT or an INPUT port on the GrovePi. Parameters pin {Integer} a number to identify the port (D2-D8) to which to do the change mode {String} \"OUTPUT\" for writing values or \"INPUT\" for reading Returns : 1 all the time","title":"GPIO Functions"},{"location":"api/gpio/#api-gpio-functions","text":"In this section the Python API reference for GPIO functions is described. This library is supported on both major versions of Python: 2.x and 3.x. IMPORTANT This library and the other ones too are not thread-safe. You cannot call the GrovePi from multiple threads or processes as that will put the GrovePi into a broken state. In case you need to reset the GrovePi from your Raspberry Pi, check this section . The functions don't verify if the input parameters are valid and therefore the parameters have to be verified/validated before that. Calling a function with improper parameters can result in an undefined behavior for the GrovePi.","title":"API - GPIO Functions"},{"location":"api/gpio/#grovepidigitalreadpin","text":"Reads whether a port's input is set high or low on the GrovePi. Parameters pin {Integer} a number to identify the port (D2-D8) from which to do the reading Returns : 0 or 1 depending on the input value","title":"grovepi.digitalRead(pin)"},{"location":"api/gpio/#grovepidigitalwritepin-value","text":"Sets the output value to either 0 or 1 to a digital port on the GrovePi. Parameters pin {Integer} a number to identify the port (D2-D8) to which to do the writing value {Integer} either 0 for 0 volts or 1 for maximum output voltage (usually 5 volts) Returns : 1 all the time","title":"grovepi.digitalWrite(pin, value)"},{"location":"api/gpio/#grovepianalogreadpin","text":"Detect an input voltage as a value from a given port on the GrovePi. Parameters pin {Integer} a number to identify the port (A0-A2) from which to do the reading Returns : a 10-bit {Integer} number that maps to the input voltage on the port","title":"grovepi.analogRead(pin)"},{"location":"api/gpio/#grovepianalogwritepin-value","text":"Set an output voltage on a PWM-enabled port by mapping the value to the desired voltage on the GrovePi. Parameters pin {Integer} a number to identify the port (ports 3, 5, 6, 9) to which to do the writing value {Integer} an 8-bit number that maps from 0V to the referenced voltage of the GrovePi (5V) Returns : 1 all the time","title":"grovepi.analogWrite(pin, value)"},{"location":"api/gpio/#grovepipinmodepin-mode","text":"Sets a port to be either an OUTPUT or an INPUT port on the GrovePi. Parameters pin {Integer} a number to identify the port (D2-D8) to which to do the change mode {String} \"OUTPUT\" for writing values or \"INPUT\" for reading Returns : 1 all the time","title":"grovepi.pinMode(pin, mode)"},{"location":"api/interrupt/","text":"API - Interrupt-Based Devices \u00b6 In this section the Python API reference for interrupt-based devices is described. This library is supported on both major versions of Python: 2.x and 3.x. The API for the following sensors is described in this section: Grove Dust Sensor Grove Encoder Grove Water Flow Sensor of whose functionality can be used in other applications too Apart from describing the API for the above sensors, there is also described a set of functions used to set interrupt events on the GrovePi. These functions are like the building blocks of the API of the above sensors and can be used for your own implementation, should it be applicable to your device. IMPORTANT This library and the other ones too are not thread-safe. You cannot call the GrovePi from multiple threads or processes as that will put the GrovePi into a broken state. In case you need to reset the GrovePi from your Raspberry Pi, check this section . The functions don't verify if the input parameters are valid and therefore the parameters have to be verified/validated before that. Calling a function with improper parameters can result in an undefined behavior for the GrovePi. grovepi.set_pin_interrupt(pin, ftype, interrupt_mode, period) \u00b6 Attach an interrupt event to a port. Can be used to count pulses, duration of pulses, set different kinds of trigger modes (on change, rising or falling edges) all done within a given time period. If there are subsequent calls to this set function without detaching the interrupt event first from a given pin, then it will overwrite the old setting and update it to reflect the latest one. Also, setting this up disables the OUTPUT functionality on the selected pin. If the selected pin has to drive the output, then detach the interrupt event with grovepi.unset_pin_interrupt . Parameters pin {Integer} can be pins D2-D8 to which the device is connected to ftype {Integer} the type of event/operation associated for the given pin. Can take values grovepi.COUNT_CHANGES (for counting the number of triggers) or grovepi.COUNT_LOW_DURATION (which measures how much time the signal stays low in a given period). interrupt_mode {Integer} triggering mode of the interrupt. It can be grovepi.CHANGE , grovepi.FALLING or grovepi.RISING , just like on the Arduino. period {Integer} specifying after how long the recorded value should be stored on the GrovePi to be subsequently read on the master device (Raspberry Pi). Measured in milliseconds. Minimum value shouldn't be too small (say under 5 ms ) and the maximum value is 65535 ms . Returns : None grovepi.unset_pin_interrupt(pin) \u00b6 Detach an interrupt event from a given pin. Necessary if you want to set output values to this pin with grovepi.digitalWrite function. Parameters pin {Integer} pins D2-D8 from which the interrupt is released from Returns : None grovepi.unset_all_interrupts() \u00b6 Detach all active interrupt events on all pins. Parameters : None Returns : None grovepi.is_interrupt_active(pin) \u00b6 Check if a pin has an interrupt event associated. Parameters pin {Integer} pin to check (D2-D8) if there's an associated interrupt event Returns : {Bool} - True if it has an interrupt event associated and False if otherwise. grovepi.get_active_interrupts() \u00b6 Get a list of all pins that have associated interrupt events. Parameters : None Returns : A list of integers representing the active pins that have interrupt events. grovepi.read_interrupt_state(pin) \u00b6 Get the recorded value by the interrupt event on the given pin. If an interrupt is set on pin D2 (D2 is taken as an example, it can be any other digital pin) with the type of operation set to grovepi.COUNT_CHANGES and mode of interrupt set to grovepi.RISING with a period set to 1000 ms , then say if 567 rising edges are detected, then at the end of this period of 1000 ms , this function will return for pin D2 value 567. And the returned value of this function on D2 pin will update every 1000 ms , because that's the period that has been set for it. And the outcome varies depending on how the interrupt event is initially set. Parameters pin {Integer} pin to check the recorded value for the associated interrupt event Returns : {Bool} - True if it has an interrupt event associated and False if otherwise. grovepi.dust_sensor_en(pin = 2, period = 30000) \u00b6 Enables the Grove Dust Sensor . If there is another interrupt event set on this pin, calling this method will overwrite the previous setting. Check grovepi.set_pin_interrupt to find out more. It's the same effect as with calling this after calling grovepi.encoder_en or grovepi.flowEnable . This function is the same as calling set_pin_interrupt(pin, ftype=COUNT_LOW_DURATION, interrupt_mode=CHANGE, period=period) . Parameters pin {Integer} the pin (D2-D8) to which the dust sensor is assigned to period {Integer} refresh time frame for the dust sensor. Maximum value for this parameter is 65535 ms. Returns : None grovepi.dust_sensor_dis(pin = 2) \u00b6 Disables the Grove Dust Sensor . To disable the dust sensor that sits on the given pin. It's the same as calling unset_pin_interrupt function. This function will be removed from future versions and it's only kept for making the API backwards-compatible. Parameters : pin {Integer} the pin (D2-D8) to which the dust sensor is connected to Returns : None grovepi.dust_sensor_read(pin = 2, period = 30000) \u00b6 Reads the low pulse occupancy of the Grove Dust Sensor in the given period of time as set with grovepi.set_pin_interrupt function. Parameters : None pin {Integer} - the pin (D2-D8) to which the dust sensor is connected to period {Integer} - refresh time frame for the dust sensor as set with grovepi.set_pin_interrupt function. Maximum value for this parameter is 65535 ms. Returns : {(Integer, Float, Float)} list 1st element is the LPO time the 2nd one is the percentage (LPO time divided by total period) the 3rd is the concentration as measured in pcs/283ml=0.01cf where the particle size is over 1um The dust sensor's characteristics can be seen in the following graph. grovepi.encoder_en(pin = 2, steps = 32) \u00b6 Enable the Grove Encoder . If the pin already has an associated interrupt event, calling this method will overwrite the setting with the new change for the given pin. Since the encoder needs two interrupt-enabled pins, when calling this function for a pin , it also attaches the next pin in line pin + 1 . To see which pins have been attached, call get_active_interrupts function. Parameters : pin {Integer} the pin to which the encoder is connected to. It also attaches the pin right next up in its line pin + 1 . Can be set for D2-D7 pins. Notice how the last one can't be used because there would have to be another pin available after it, but there isn't because it's the last one in the chain. steps {Integer} specifies the number of steps for the encoder Returns : None grovepi.encoder_dis(pin = 2) \u00b6 Disable the Grove Encoder . Necessary if you want to set output values to this pin with grovepi.digitalWrite function. It's the same as calling unset_pin_interrupt function for pin and pin + 1 . Parameters : pin {Integer} the pin (D2-D8) to which the flow sensor is connected to Returns : None grovepi.encoderRead(pin = 2) \u00b6 Read the data off of the Grove Encoder . Parameters : pin {Integer} - the pin (D2-D7) to which the encoder is attached to. Returns : {Integer} the current position of the encoder grovepi.flowEnable(pin = 2, period = 2000) \u00b6 Enables the Grove Water Flow Sensor . This function literally counts the number of rising pulses in the given time period. Because of that, calling this is the same as calling set_pin_interrupt(pin, ftype=COUNT_CHANGES, interrupt_mode=RISING, period=period) for pin . If the pin already has an associated interrupt event, calling this method will overwrite the setting with the new change for the given pin. This function will be removed from future versions and it's only kept for making the API backwards-compatible. Parameters pin {Integer} the pin (D2-D8) to which the dust sensor is assigned to period {Integer} refresh time frame for the dust sensor. Maximum value for this parameter is 65535 ms. Returns : None grovepi.flowDisable(pin = 2) \u00b6 Disables the Grove Water Flow Sensor . Necessary if you want to set output values to this pin with grovepi.digitalWrite function. It's the same as calling unset_pin_interrupt function. This function will be removed from future versions and it's only kept for making the API backwards-compatible. Parameters : pin {Integer} the pin (D2-D8) to which the flow sensor is connected to Returns : None grovepi.flowRead(pin = 2) \u00b6 Enables the Grove Water Flow Sensor . This function counts the number of rising pulses in the time period set with grovepi.flowEnable . It's the same as calling grovepi.read_interrupt_state for the given pin. Parameters : pin {Integer} the pin (D2-D8) to which the flow sensor is connected to Returns : {Integer} number of rising pulses that occurred within the given time frame","title":"Interrupt-Based Devices"},{"location":"api/interrupt/#api-interrupt-based-devices","text":"In this section the Python API reference for interrupt-based devices is described. This library is supported on both major versions of Python: 2.x and 3.x. The API for the following sensors is described in this section: Grove Dust Sensor Grove Encoder Grove Water Flow Sensor of whose functionality can be used in other applications too Apart from describing the API for the above sensors, there is also described a set of functions used to set interrupt events on the GrovePi. These functions are like the building blocks of the API of the above sensors and can be used for your own implementation, should it be applicable to your device. IMPORTANT This library and the other ones too are not thread-safe. You cannot call the GrovePi from multiple threads or processes as that will put the GrovePi into a broken state. In case you need to reset the GrovePi from your Raspberry Pi, check this section . The functions don't verify if the input parameters are valid and therefore the parameters have to be verified/validated before that. Calling a function with improper parameters can result in an undefined behavior for the GrovePi.","title":"API - Interrupt-Based Devices"},{"location":"api/interrupt/#grovepiset_pin_interruptpin-ftype-interrupt_mode-period","text":"Attach an interrupt event to a port. Can be used to count pulses, duration of pulses, set different kinds of trigger modes (on change, rising or falling edges) all done within a given time period. If there are subsequent calls to this set function without detaching the interrupt event first from a given pin, then it will overwrite the old setting and update it to reflect the latest one. Also, setting this up disables the OUTPUT functionality on the selected pin. If the selected pin has to drive the output, then detach the interrupt event with grovepi.unset_pin_interrupt . Parameters pin {Integer} can be pins D2-D8 to which the device is connected to ftype {Integer} the type of event/operation associated for the given pin. Can take values grovepi.COUNT_CHANGES (for counting the number of triggers) or grovepi.COUNT_LOW_DURATION (which measures how much time the signal stays low in a given period). interrupt_mode {Integer} triggering mode of the interrupt. It can be grovepi.CHANGE , grovepi.FALLING or grovepi.RISING , just like on the Arduino. period {Integer} specifying after how long the recorded value should be stored on the GrovePi to be subsequently read on the master device (Raspberry Pi). Measured in milliseconds. Minimum value shouldn't be too small (say under 5 ms ) and the maximum value is 65535 ms . Returns : None","title":"grovepi.set_pin_interrupt(pin, ftype, interrupt_mode, period)"},{"location":"api/interrupt/#grovepiunset_pin_interruptpin","text":"Detach an interrupt event from a given pin. Necessary if you want to set output values to this pin with grovepi.digitalWrite function. Parameters pin {Integer} pins D2-D8 from which the interrupt is released from Returns : None","title":"grovepi.unset_pin_interrupt(pin)"},{"location":"api/interrupt/#grovepiunset_all_interrupts","text":"Detach all active interrupt events on all pins. Parameters : None Returns : None","title":"grovepi.unset_all_interrupts()"},{"location":"api/interrupt/#grovepiis_interrupt_activepin","text":"Check if a pin has an interrupt event associated. Parameters pin {Integer} pin to check (D2-D8) if there's an associated interrupt event Returns : {Bool} - True if it has an interrupt event associated and False if otherwise.","title":"grovepi.is_interrupt_active(pin)"},{"location":"api/interrupt/#grovepiget_active_interrupts","text":"Get a list of all pins that have associated interrupt events. Parameters : None Returns : A list of integers representing the active pins that have interrupt events.","title":"grovepi.get_active_interrupts()"},{"location":"api/interrupt/#grovepiread_interrupt_statepin","text":"Get the recorded value by the interrupt event on the given pin. If an interrupt is set on pin D2 (D2 is taken as an example, it can be any other digital pin) with the type of operation set to grovepi.COUNT_CHANGES and mode of interrupt set to grovepi.RISING with a period set to 1000 ms , then say if 567 rising edges are detected, then at the end of this period of 1000 ms , this function will return for pin D2 value 567. And the returned value of this function on D2 pin will update every 1000 ms , because that's the period that has been set for it. And the outcome varies depending on how the interrupt event is initially set. Parameters pin {Integer} pin to check the recorded value for the associated interrupt event Returns : {Bool} - True if it has an interrupt event associated and False if otherwise.","title":"grovepi.read_interrupt_state(pin)"},{"location":"api/interrupt/#grovepidust_sensor_enpin-2-period-30000","text":"Enables the Grove Dust Sensor . If there is another interrupt event set on this pin, calling this method will overwrite the previous setting. Check grovepi.set_pin_interrupt to find out more. It's the same effect as with calling this after calling grovepi.encoder_en or grovepi.flowEnable . This function is the same as calling set_pin_interrupt(pin, ftype=COUNT_LOW_DURATION, interrupt_mode=CHANGE, period=period) . Parameters pin {Integer} the pin (D2-D8) to which the dust sensor is assigned to period {Integer} refresh time frame for the dust sensor. Maximum value for this parameter is 65535 ms. Returns : None","title":"grovepi.dust_sensor_en(pin = 2, period = 30000)"},{"location":"api/interrupt/#grovepidust_sensor_dispin-2","text":"Disables the Grove Dust Sensor . To disable the dust sensor that sits on the given pin. It's the same as calling unset_pin_interrupt function. This function will be removed from future versions and it's only kept for making the API backwards-compatible. Parameters : pin {Integer} the pin (D2-D8) to which the dust sensor is connected to Returns : None","title":"grovepi.dust_sensor_dis(pin = 2)"},{"location":"api/interrupt/#grovepidust_sensor_readpin-2-period-30000","text":"Reads the low pulse occupancy of the Grove Dust Sensor in the given period of time as set with grovepi.set_pin_interrupt function. Parameters : None pin {Integer} - the pin (D2-D8) to which the dust sensor is connected to period {Integer} - refresh time frame for the dust sensor as set with grovepi.set_pin_interrupt function. Maximum value for this parameter is 65535 ms. Returns : {(Integer, Float, Float)} list 1st element is the LPO time the 2nd one is the percentage (LPO time divided by total period) the 3rd is the concentration as measured in pcs/283ml=0.01cf where the particle size is over 1um The dust sensor's characteristics can be seen in the following graph.","title":"grovepi.dust_sensor_read(pin = 2, period = 30000)"},{"location":"api/interrupt/#grovepiencoder_enpin-2-steps-32","text":"Enable the Grove Encoder . If the pin already has an associated interrupt event, calling this method will overwrite the setting with the new change for the given pin. Since the encoder needs two interrupt-enabled pins, when calling this function for a pin , it also attaches the next pin in line pin + 1 . To see which pins have been attached, call get_active_interrupts function. Parameters : pin {Integer} the pin to which the encoder is connected to. It also attaches the pin right next up in its line pin + 1 . Can be set for D2-D7 pins. Notice how the last one can't be used because there would have to be another pin available after it, but there isn't because it's the last one in the chain. steps {Integer} specifies the number of steps for the encoder Returns : None","title":"grovepi.encoder_en(pin = 2, steps = 32)"},{"location":"api/interrupt/#grovepiencoder_dispin-2","text":"Disable the Grove Encoder . Necessary if you want to set output values to this pin with grovepi.digitalWrite function. It's the same as calling unset_pin_interrupt function for pin and pin + 1 . Parameters : pin {Integer} the pin (D2-D8) to which the flow sensor is connected to Returns : None","title":"grovepi.encoder_dis(pin = 2)"},{"location":"api/interrupt/#grovepiencoderreadpin-2","text":"Read the data off of the Grove Encoder . Parameters : pin {Integer} - the pin (D2-D7) to which the encoder is attached to. Returns : {Integer} the current position of the encoder","title":"grovepi.encoderRead(pin = 2)"},{"location":"api/interrupt/#grovepiflowenablepin-2-period-2000","text":"Enables the Grove Water Flow Sensor . This function literally counts the number of rising pulses in the given time period. Because of that, calling this is the same as calling set_pin_interrupt(pin, ftype=COUNT_CHANGES, interrupt_mode=RISING, period=period) for pin . If the pin already has an associated interrupt event, calling this method will overwrite the setting with the new change for the given pin. This function will be removed from future versions and it's only kept for making the API backwards-compatible. Parameters pin {Integer} the pin (D2-D8) to which the dust sensor is assigned to period {Integer} refresh time frame for the dust sensor. Maximum value for this parameter is 65535 ms. Returns : None","title":"grovepi.flowEnable(pin = 2, period = 2000)"},{"location":"api/interrupt/#grovepiflowdisablepin-2","text":"Disables the Grove Water Flow Sensor . Necessary if you want to set output values to this pin with grovepi.digitalWrite function. It's the same as calling unset_pin_interrupt function. This function will be removed from future versions and it's only kept for making the API backwards-compatible. Parameters : pin {Integer} the pin (D2-D8) to which the flow sensor is connected to Returns : None","title":"grovepi.flowDisable(pin = 2)"},{"location":"api/interrupt/#grovepiflowreadpin-2","text":"Enables the Grove Water Flow Sensor . This function counts the number of rising pulses in the time period set with grovepi.flowEnable . It's the same as calling grovepi.read_interrupt_state for the given pin. Parameters : pin {Integer} the pin (D2-D8) to which the flow sensor is connected to Returns : {Integer} number of rising pulses that occurred within the given time frame","title":"grovepi.flowRead(pin = 2)"},{"location":"dev/","text":"Development Notes \u00b6 To fire up a development environment for the documentation, you need to build this docker file first docker image build -t dexterind/grovepi-docs . Once you have that, you need to fire up the container. First make sure you are running this from the root of this repository and then run docker container run -v $(pwd)/docs:/docs -it --rm -p 80:8000 dexterind/grovepi-docs To have the documentation built run from the root of this repository docker container run -v $(pwd)/docs:/docs -it --rm dexterind/grovepi-docs mkdocs build -c and wait for it to exit the process and then copy the contents of the newly created directory site and place it into the /docs directory. Enjoy developing and when you're done with it, build the documentation and save the statics in the docs folder.","title":"Development Notes"},{"location":"dev/#development-notes","text":"To fire up a development environment for the documentation, you need to build this docker file first docker image build -t dexterind/grovepi-docs . Once you have that, you need to fire up the container. First make sure you are running this from the root of this repository and then run docker container run -v $(pwd)/docs:/docs -it --rm -p 80:8000 dexterind/grovepi-docs To have the documentation built run from the root of this repository docker container run -v $(pwd)/docs:/docs -it --rm dexterind/grovepi-docs mkdocs build -c and wait for it to exit the process and then copy the contents of the newly created directory site and place it into the /docs directory. Enjoy developing and when you're done with it, build the documentation and save the statics in the docs folder.","title":"Development Notes"}]}